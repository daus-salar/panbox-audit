/*
 * 
 *               Panbox - encryption for cloud storage 
 *      Copyright (C) 2014-2015 by Fraunhofer SIT and Sirrix AG 
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * Additonally, third party code may be provided with notices and open source
 * licenses from communities and third parties that govern the use of those
 * portions, and any licenses granted hereunder do not alter any rights and
 * obligations you may have under such open source licenses, however, the
 * disclaimer of warranty and limitation of liability provisions of the GPLv3 
 * will apply to all the product.
 * 
 */
package org.panbox.core.crypto.randomness;

import org.panbox.core.exception.RandomDataGenerationException;

/**
 * @author palige
 * 
 *         Class implements several statistical tests to verify the randomness
 *         of data generated by a PRNG, as partially set forth
 *         by BSI (AIS20/AIS31) and in ISO18031
 * 
 */
public class RandomnessQualityCheck {

	/**
	 * saves the borders to compare with
	 */
	private IRandomnessQualityRanges ranges;

	public void setBorders(IRandomnessQualityRanges ranges) {
		this.ranges = ranges;
	}

	/**
	 * implements the Monobit-Test (T1)
	 * 
	 * @param bitstring
	 *            bit string of length 20000 ( = 2500 bytes)
	 * @return <code>true</code> iff data pass the test, otherwise
	 *         <code>false</code>
	 */
	public boolean monobitTest(byte[] bitstring) throws RandomDataGenerationException {
		if (bitstring.length != ranges.getBitstreamLength())
			throw new RandomDataGenerationException("Invalid bitstring length");
		int counter = countBits(bitstring);

		if ((counter < ranges.getMonobitBorders()[1])
				&& (counter > ranges.getMonobitBorders()[0])) {
			return true;
		}

		return false;
	}

	/**
	 * counts the number of bits set in the passed byte-array
	 * 
	 * @param bitstring
	 *            byte-array of arbitrary length
	 * @return number of set bits
	 */
	private static int countBits(byte[] bitstring) {
		int nBits = bitstring.length * 8;
		int counter = 0;

		for (int i = 0; i < nBits; i++) {
			// each bit in the bytearray is parsed
			int curBit = 1 << (i % 8);
			// index in bytearray defines byte-ordering (little or big endian)
			byte curByte = bitstring[(i / 8)];
			if ((curBit & curByte) > 0) {
				counter++;
			}
		}
		return counter;
	}

	// /**
	// * counts the number of bits set in the passed byte-array
	// *
	// * @param bitstring
	// * byte-array of arbitrary length
	// * @return number of set bits
	// */
	// private static int countBitsB(byte[] arg) {
	// byte[] copy = Arrays.clone(arg);
	// int sum = 0;
	// for (int i = 0; i < copy.length; i++) {
	// if (copy[i]<0) {
	// sum++;
	// copy[i] >>>= 1;
	// }
	// int b;
	// for (b = 0; copy[i] > 0; b++) {
	// copy[i] &= copy[i] - 1;
	// }
	// sum += b;
	// }
	// return sum;
	// }

	/**
	 * implements the Poker-Test (T2)
	 * 
	 * @param bitstring
	 *            bit string of length 20000
	 * @return <code>true</code> iff data pass the test, otherwise
	 *         <code>false</code>
	 */
	public boolean pokerTest(byte[] bitstring) throws RandomDataGenerationException {
		if (bitstring.length != ranges.getBitstreamLength())
			throw new RandomDataGenerationException("Invalid bitstring length");
		int[] numSet = new int[16];
		for (int i = 0; i < bitstring.length; i++) {
			// the upper 4 bits
			int res = bitstring[i] & 0xF0;
			// numSet[bitstring[i] & 0xF0]++;
			numSet[res >>> 4]++;

			// the lower 4 bits
			numSet[bitstring[i] & 0xF]++;
		}

		int sum = 0;
		for (int i = 0; i < numSet.length; i++) {
			sum += (numSet[i] * numSet[i]);
		}
		double Y = 0.0032 * sum - 5000;
		if ((Y > ranges.getPokerBorders()[0])
				&& (Y < ranges.getPokerBorders()[1]))
			return true;
		return false;
	}

	/**
	 * implements the Run-Test (T3)
	 * 
	 * @param bitstring
	 *            bit string of length 20000
	 * @return <code>true</code> iff data pass the test, otherwise
	 *         <code>false</code>
	 */
	public boolean runTest(byte[] bitstring) throws RandomDataGenerationException {
		if (bitstring.length != ranges.getBitstreamLength())
			throw new RandomDataGenerationException("Invalid bitstring length");
		int[] distribution0 = new int[6];
		int[] distribution1 = new int[6];
		int ctr = 0;
		boolean parity = false;

		int nBits = ranges.getBitstreamLength() * 8;

		for (int i = 0; i < nBits; i++) {
			// each bit in the bytearray is parsed
			int curBit = 1 << (7 - (i % 8));
			byte curByte = bitstring[(i / 8)];
			if ((curBit & curByte) > 0) {
				// we got a 1
				if (parity == false) {
					// we left a 0-run
					// save previous run, switch parity, restart counting
					if (i != 0) {
						if (ctr < 6) {
							distribution0[ctr - 1]++;
						} else {
							distribution0[5]++;
						}
						// System.out.println(" - 0run: " + ctr +
						// "er group - ");
					}
					parity = true;
					ctr = 1;
				} else if (parity == true) {
					// we are still in a 1-run
					ctr++;
				}
				// last run, no parity change
				if (i == (nBits - 1)) {
					if (ctr < 6) {
						distribution0[ctr - 1]++;
					} else {
						distribution0[5]++;
					}
				}
				// System.out.print("1");
			} else {
				// we got a 0
				if (parity == true) {
					// we left a 1-run
					// save previous run, switch parity, restart counting
					if (i != 0) {
						if (ctr < 6) {
							distribution1[ctr - 1]++;
						} else {
							distribution1[5]++;
						}
						// System.out.println(" - 1run: " + ctr +
						// "er group - ");
					}
					parity = false;
					ctr = 1;
				} else if (parity == false) {
					// we are still in a 0-run
					ctr++;
				}
				if (i == (nBits - 1)) {
					if (ctr < 6) {
						distribution1[ctr - 1]++;
					} else {
						distribution1[5]++;
					}
				}
				// System.out.print("0");
			}
		}
		// check results
		int[][] temp = new int[][] { distribution0, distribution1 };
		for (int i = 0; i < temp.length; i++) {
			int[] a = temp[0];
			if ((a[0] < ranges.getRunsBorders()[0][0])
					|| (a[0] > ranges.getRunsBorders()[0][1])
					|| (a[1] < ranges.getRunsBorders()[1][0])
					|| (a[1] > ranges.getRunsBorders()[1][1])
					|| (a[2] < ranges.getRunsBorders()[2][0])
					|| (a[2] > ranges.getRunsBorders()[2][1])
					|| (a[3] < ranges.getRunsBorders()[3][0])
					|| (a[3] > ranges.getRunsBorders()[3][1])
					|| (a[4] < ranges.getRunsBorders()[4][0])
					|| (a[4] > ranges.getRunsBorders()[4][1])
					|| (a[5] < ranges.getRunsBorders()[5][0])
					|| (a[5] > ranges.getRunsBorders()[5][1]))
				return false;
		}
		return true;
	}

	/**
	 * implements the Longrun-Test (T4)
	 * 
	 * @param bitstring
	 *            bit string of length 20000
	 * @return <code>true</code> iff data pass the test, otherwise
	 *         <code>false</code>
	 */
	public boolean longrunTest(byte[] bitstring) throws RandomDataGenerationException {
		if (bitstring.length != ranges.getBitstreamLength())
			throw new RandomDataGenerationException("Invalid bitstring length");
		int nBits = ranges.getBitstreamLength() * 8;
		int counter0 = 0;
		int counter1 = 0;
		for (int i = 0; i < nBits; i++) {
			// each bit in the bytearray is parsed
			int curBit = 1 << (7 - (i % 8));
			// index in bytearray defines byte-ordering (little or big endian)
			byte curByte = bitstring[(i / 8)];
			if ((curBit & curByte) > 0) {
				// we got a 1
				counter0 = 0;
				counter1++;
				if (counter1 > ranges.getLongrunsBorder())
					return false;
			} else {
				// we got a 0
				counter1 = 0;
				counter0++;
				if (counter0 > ranges.getLongrunsBorder())
					return false;
			}
		}
		return true;
	}

	/**
	 * implements the Autocorrelation-Test (T5) as defined in AIS 20
	 * 
	 * @param bitstring
	 *            bit string of length 20000
	 * @return <code>true</code> iff data pass the test, otherwise
	 *         <code>false</code>
	 */
	public boolean autocorrelationTest(byte[] bitstring) throws RandomDataGenerationException {
		int nBits = ranges.getBitstreamLength() * 2; // 5000, as defined in
		// AIS20
		int delta = ranges.getBitstreamLength() * 2; // tau as defined in AIS20
		for (int a = 1; a <= delta; a++) {
			// for every new distance the counter is reset
			int counter = 0;
			for (int j = 0; j < nBits; j++) {
				// current bit in original bitstring
				int origVal = (1 << (7 - (j % 8))) & bitstring[(j / 8)];
				int shiftedVal = (1 << (7 - ((j + a) % 8)))
						& bitstring[((j + a) / 8)];

				// increase counter iff exactly one of two bits is set
				if (((origVal == 0) && (shiftedVal > 0))
						|| ((origVal > 0) && (shiftedVal == 0))) {
					counter++;
				}
			}
			if ((counter <= ranges.getAutocorrelationBorders()[0])
					|| (counter >= ranges.getAutocorrelationBorders()[1])) {
				System.err.println(counter);
				return false;
			} else {
				//System.out.println(counter);
			}
		}
		return true;
	}
}
